{
  "hash": "8237d305364e3d8c51960ca7d231cc5c",
  "result": {
    "markdown": "---\ntitle: \"Storing custom token classification labels in a Hugging Face dataset\"\ndate: \"2022-12-18\"\ncategories: [\"tips and tricks\"]\nimage: \"fish.png\"\n---\n\nIn [my previous blog post](../01_Detecting-OCR-mistakes-experiment-1/index.qmd),\nI showed how I created a Hugging Face dataset for detecting OCR mistakes.\nOne thing thing that annoyed me about this dataset is that it didn't contain the\nnames of the token labels. I searched for the solution and tried different\nthings, but couldn't figure out how to do it. Then finally, when I had some time\nand was browsing\n[the Hugging Face dataset documentation](https://huggingface.co/docs/datasets/package_reference/main_classes#datasets.DatasetDict),\nI found methods `cast()` and `cast_column()` that allow you update the dataset\nfeatures and properly set the class labels. Here is how to do it.\n\n[![Twelve species of fish, Carl Cristiaan Fuchs (1802 - 1855)](fish.png)](http://hdl.handle.net/10934/RM0001.COLLECT.309516)\n\nFirst, load the dataset without the class labels:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nfrom datasets import load_from_disk\n\ndataset = load_from_disk('data/dataset')\n```\n:::\n\n\nA sample from this dataset has the following features:\n\n```python\ndataset['train'][0]\n```\n\n```\n{\n    'key': 'FR/FR1/499.txt',\n    'start_token_id': 0,\n    'score': 0.0464135021,\n    'tokens': ['Johannes,', 'Dei', 'gratia,', 'Francorum', 'rex.', 'Notum', 'facimus', 'universis,', 'tam', 'presentibus', 'quam', 'futuris,', 'nobis,', 'ex', 'parte', 'Petri', 'juvenis', 'sentiferi', 'qui', 'bene', 'et', 'fideliter', 'in', 'guerris', 'nostris', 'nobis', 'servivit', 'expositum', 'fuisse,', 'qod', 'cum', 'ipse,', 'tam', 'nomine', 'suo'],\n    'tags': [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0],\n    'language': 'FR'\n}\n\n```\n\nWhen looking at the features of the dataset, we see that the `tags` column is of\ntype (`Sequence` of) `Value` (and not of (`Sequence` of) `ClassLabel`).\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ndataset['train'].features\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n{'key': Value(dtype='string', id=None),\n 'language': Value(dtype='string', id=None),\n 'score': Value(dtype='float64', id=None),\n 'start_token_id': Value(dtype='int64', id=None),\n 'tags': Sequence(feature=Value(dtype='int64', id=None), length=-1, id=None),\n 'tokens': Sequence(feature=Value(dtype='string', id=None), length=-1, id=None)}\n```\n:::\n:::\n\n\nThe next step is to call the `cast_column` method with the correct properties:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nfrom datasets import Sequence, ClassLabel\n\ndataset = dataset.cast_column('tags', Sequence(feature=ClassLabel(num_classes=3, names=['O', 'OCR-Mistake-B', 'OCR-Mistake-I']), length=-1))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading cached processed dataset at data/dataset/train/cache-7695d0b08b5f7b4d.arrow\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading cached processed dataset at data/dataset/val/cache-b0a1c2c8a428d020.arrow\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading cached processed dataset at data/dataset/test/cache-9e879e4bbea50e50.arrow\n```\n:::\n:::\n\n\nAfter this update, the label names and label to name mapping are stored in the dataset:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndataset['train'].features[\"tags\"].feature.names\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n['O', 'OCR-Mistake-B', 'OCR-Mistake-I']\n```\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ndataset['train'].features[\"tags\"].feature._str2int\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n{'O': 0, 'OCR-Mistake-B': 1, 'OCR-Mistake-I': 2}\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}